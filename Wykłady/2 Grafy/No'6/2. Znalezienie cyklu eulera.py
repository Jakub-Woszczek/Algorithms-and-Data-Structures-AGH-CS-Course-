L = [[0,1],[1,5],[2,1],[2,0],[1,4],[4,5],[5,3],[4,3],[4,2],[2,6],[3,6],[5,7],[3,8],[8,7]]
# L_2 = [[1,2],[2,3],[1,4],[2,4],[7,3],[3,6],[5,3],[1,5]]
L_2=[(0, 3, 9900), (0, 5, 10470), (0, 6, 10520), (0, 9, 9580), (0, 10, 9420), (0, 11, 9520), (0, 12, 9870), (0, 14, 10010), (0, 20, 10490), (0, 22, 9670), (0, 27, 9490), (0, 28, 10180), (1, 2, 10240), (1, 5, 9890), (1, 8, 9600), (1, 12, 9410), (1, 15, 10350), (1, 19, 10170), (1, 25, 10080), (1, 26, 9810), (1, 30, 9460), (2, 4, 9680), (2, 6, 9630), (2, 10, 10160), (2, 12, 9850), (2, 14, 9500), (2, 18, 9580), (2, 22, 9680), (2, 24, 10420), (2, 26, 10000), (2, 30, 9680), (3, 6, 10300), (3, 7, 9570), (3, 8, 9500), (3, 11, 10480), (3, 12, 9920), (3, 15, 9910), (3, 16, 9570), (3, 22, 9790), (3, 27, 9630), (3, 29, 10540), (4, 5, 9680), (4, 10, 10130), (4, 15, 9730), (4, 17, 10220), (4, 18, 10520), (4, 21, 9710), (4, 23, 9870), (4, 24, 9670), (4, 25, 9660), (4, 26, 10190), (4, 27, 10480), (4, 28, 10110), (4, 29, 9570), (5, 14, 9730), (5, 17, 10600), (5, 18, 9480), (5, 19, 9800), (5, 20, 10210), (5, 27, 9750), (5, 29, 9500), (5, 30, 9400), (6, 10, 9590), (6, 13, 9490), (6, 14, 9860), (6, 18, 9640), (6, 19, 10200), (6, 21, 9770), (6, 22, 10510), (6, 24, 9980), (6, 25, 9900), (6, 29, 10360), (7, 8, 9810), (7, 9, 10310), (7, 10, 9960), (7, 12, 10420), (7, 15, 10350), (7, 18, 10440), (7, 19, 10440), (7, 24, 9820), (7, 26, 10350), (7, 27, 9510), (7, 30, 10260), (8, 12, 9970), (8, 13, 9740), (8, 15, 10510), (8, 16, 9400), (8, 18, 10080), (8, 21, 9770), (8, 24, 10440), (8, 25, 9850), (8, 28, 10290), (8, 30, 10180), (9, 13, 9980), (9, 14, 9400), (9, 15, 10470), (9, 22, 9580), (9, 25, 9600), (9, 26, 9720), (9, 27, 9530), (9, 28, 10220), (10, 11, 9970), (10, 12, 9530), (10, 14, 9550), (10, 17, 10060), (10, 19, 9540), (10, 20, 9420), (10, 23, 10400), (10, 24, 9730), (10, 26, 9960), (10, 27, 9440), (10, 29, 9770), (10, 30, 10160), (11, 13, 9760), (11, 16, 10160), (11, 18, 10570), (11, 19, 10090), (11, 20, 9640), (11, 24, 9600), (11, 27, 10300), (11, 29, 10070), (12, 13, 10500), (12, 16, 9860), (12, 18, 10420), (12, 22, 9670), (12, 24, 9820), (12, 27, 10530), (12, 29, 9490), (13, 16, 10370), (13, 17, 10480), (13, 20, 9410), (13, 21, 10480), (13, 25, 9460), (13, 26, 9670), (13, 27, 9550), (13, 28, 9600), (14, 16, 10050), (14, 18, 9460), (14, 19, 9850), (14, 20, 9870), (14, 22, 10060), (14, 26, 9450), (14, 28, 9990), (15, 20, 9450), (15, 25, 10380), (15, 26, 9470), (15, 30, 9870), (16, 22, 10120), (16, 26, 10470), (16, 27, 9930), (16, 29, 10500), (17, 18, 10090), (17, 21, 9940), (17, 22, 10010), (17, 24, 10500), (17, 26, 10280), (18, 21, 10570), (18, 22, 10430), (18, 23, 10010), (18, 25, 10120), (18, 30, 10160), (19, 27, 10130), (20, 22, 10210), (20, 23, 10420), (20, 24, 10390), (20, 29, 9850), (21, 22, 9680), (21, 28, 10040), (21, 29, 9720), (21, 30, 9500), (22, 24, 9560), (22, 25, 9800), (22, 26, 10530), (22, 30, 10560), (23, 25, 9540), (23, 27, 10550), (23, 28, 9670), (24, 25, 9800), (24, 26, 9660), (24, 29, 9920), (25, 30, 9910), (26, 27, 10500), (26, 28, 9770), (26, 29, 9790), (26, 30, 9850), (27, 28, 10560), (29, 30, 10420)]

def find_euler_cycle(L):

    # Tworzę tablice z kolejnymi wierzchołkami z cyklu i czy wieszchołek ma jeszcze jakieś krawędzie
    cycle_arr =  []
    n = len(L)
    # has_vertexes = []
    # for i in L:

    def czy_graph_ma_jeszcze_krawędzie(L): # Funkcja zwraca True jeżeli ma, False jezeli nie ma
        for i in L:
            if i != None:
                return True
        return False

    def DFS(orgin,L):
        print(orgin)
        # Bruh oczywiście warun końcowy rekurzjiiiiiiiiiiiiiii
        for i in range(n):
            if L[i] != None:
                break
            elif i == n-1 and L[i] == None:
                # Trzeba jejszcze dopisać ten wierchołek do listy cycle_arr
                cycle_arr.insert(0,orgin)
                return



        for vertex_index in range(n): # Biore po kolei krawędzie, typu vertex = [0,1]
            # Tutaj parze czy istnieje i czy jest połączona
            if L[vertex_index] != None and L[vertex_index][0] == orgin:
                # Tutaj robie seeda na następny wierchołek
                next_org = L[vertex_index][1]
                # Usuwam krawędź z listy krawędzi
                L[vertex_index] = None
                # Odpalam DFS do następnej krawędzi
                DFS(next_org,L)


            if L[vertex_index] != None and L[vertex_index][1] == orgin:
                next_org = L[vertex_index][0]
                L[vertex_index] = None
                DFS(next_org,L)

        # No i tutaj trzeba przypisać jeszcze aktualny wierchołek hurka durka
        cycle_arr.insert(0,orgin)

    orgin = 0
    while czy_graph_ma_jeszcze_krawędzie(L) != False:
        print(f'czy grapfh ma kraw{orgin}')
        # Tutaj mamy zarodki cyklów, orgin to index zarodka, przejdzie po każdym

        DFS(orgin,L)

        orgin +=1

    return cycle_arr

print(find_euler_cycle(L))

