#Wojciech Michaluk
#Algorytm dla każdego pola labiryntu zapisuje
#największą liczbę pól, które można odwiedzić na
#drodze do tego pola (-1 oznacza, że do tego pola
#nie da się dojść). W tym celu w pierwszej kolumnie
#staramy się zajść najdalej jak się da w dół, a każda
#następna kolumna wypełniana jest według zasady:
#jeżeli można wejść na to pole "z lewej" to najpierw
#przepisujemy wartości z poprzedniej, a poźniej
#przechodzimy po kolumnie od góry w dół i od dołu
#do góry, próbując znaleźć "dłuższą" ścieżkę. Szacuję
#złożoność czasową i pamięciową algorytmu na O(n^2).


def maze( L ):
    def can_move_to(L, x, y):
        return L[x][y] != '#'
    n=len(L)
    D=[[[-1,-1] for _ in range(n)] for _ in range(n)]
    for i in range(n):
        if can_move_to(L,i,0):
            D[i][0][1]=i
        else: break
    for j in range(1,n):
        for k in range(n):
            m=max(D[k][j-1])
            if m!=-1 and can_move_to(L,k,j):
                D[k][j]=[m+1,m+1]
        for k in range(1,n):
            if can_move_to(L,k,j) and D[k-1][j][1]!=-1:
                D[k][j][1]=max(D[k][j][1],D[k-1][j][1]+1)
        for k in range(n-2,-1,-1):
            if can_move_to(L,k,j) and D[k+1][j][0]!=-1:
                D[k][j][0]=max(D[k][j][0],D[k+1][j][0]+1)

    return D
Maze_test_4 = ['..#.........#......#..........#.......#.#.........', '...........##..#....##.#.......#.#....#.#.#.#.....', '.#.#.......##.........#..#..#.#..#.....#...#......', '......#...#....#....................#......#...#..', '....#.....#...............#..#.#......##...#....#.', '....#.....#...##..##..#....#........#..........#..', '#......#...............#...#..###..#......#......#', '.....#.#.....#.....#............#.#.#........#...#', '....#.....#.....#....#....#..#..............###...', '#..##...##........##..#...#................#####..', '.#..........##...............#.............##..#..', '..........#..#....#...##.......##.#.#......#......', '..#.#.#....#........#..##....#...##...............', '...#..........#.#.##.#.......##..#....#####.......', '...#........#.#...#..###..#..#..#........##..#....', '.....##......#...##.#.#.........#...#...#.....##..', '.#..#................#.#..#.#...##.#.....##...#...', '........#.#....##....#..###.#.......#....#.#.#...#', '.#.....#.......#.........#.#.........##.#....#....', '..#.##.....#...........#.....##............#.....#', '..#..........#.......##.#.#...........#..#........', '.#####.##.#.........#..............##..#..#.#.##..', '...#........#...###..#................#...........', '.......................#.....#...#................', '#.#.....................#.#........#...........#..', '.####..#...#.#.#.....#..........#.#.....#.#.##...#', '#.....##..#..#..#...#.#........#.#......#.#.......', '........####.........................#.......#....', '......##...##.#.......#.#.......##...#...#......#.', '...#........#..#................#.#..#.#..........', '................##.#..#........#..............#...', '.#....#............#...#...##.#..#.#.#............', '..#..#..#..#..#..#...#.##.#.....#..........#......', '#....#.....#..#.##.#.###......#....#.#.........#..', '......#........#..##....#..........#...#..........', '#..........#........#....#...#.....###.#..#.#..#..', '............#....#.##......#.#..........#.#.....#.', '#..#.#.##...............#.......#.##...##.#....#..', '.#....##....#.........#...#.#.....##.#.....##...#.', '#..........#........#..#.#.#...#...#....#.........', '.#....#....#...##..........#.......#......#.......', '..#...#.....#..#.....#.........#...##.#....#.#....', '......#.........#........##...#..#.#.#..#.....#...', '...##....#....##.##...#..#..####.....##......#.###', '..#........#......#.............#......#...#......', '#...........#....#..#..###......#...#..###..#.....', '..#.#.......#.#............#...#......#...........', '.#....#.........#..#..#...#....##.#.#..#..#.......', '#......#..#.#..##......#...#..#.###.......#...#...', '...#...##..#.......................##....#.....#..']

def wyciągnięcie_pierwszego_indexu(L):
    n = len(L)
    T = [["#" for _ in range(n)] for _ in range(n)]
    for i in range(n):
        for j in range(n):
            if L[i][j][0] != -1:
                T[i][j] = max(L[i][j][0],L[i][j][1])
    return T
def print_straight(T):
    # Zamień None na '#'
    formatted_T = [[('#' if item is None else item) for item in row] for row in T]

    # Oblicz maksymalną szerokość każdej kolumny
    column_widths = [max(len(str(formatted_T[i][j])) for i in range(len(formatted_T))) for j in range(len(formatted_T[0]))]

    # Wypośrodkuj kolumny
    for row in formatted_T:
        row_str = " ".join(f"{str(row[col]).rjust(column_widths[col])}" for col in range(len(row)))
        print(row_str)

# print(maze(Maze_test_4))
T = maze(Maze_test_4)
T = wyciągnięcie_pierwszego_indexu(T)
# for bruh in T:
#     print(bruh)
print_straight(T)